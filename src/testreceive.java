/*
 */ 

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.net.*;
import java.util.*;

public class testreceive
{
//	String interfaceName = "10.0.9.30";
	String interfaceName = "eth0";
	String networkGroup = "239.192.0.1";
	int udpEncapsulationPort = 7500;
	int dataSourcePort = 0;
	int dataDestinationPort = 7500;
	int max_tpdu = 1500;
	int rxw_sqns = 128;
	int rxw_secs = 0;
	long rxw_max_rte = 0;
	long lastCommit = 0;
	boolean canReceiveData = true;
	boolean isReset = false;
	Hashtable<TransportSessionId, Peer> peers = new Hashtable<TransportSessionId, Peer>();
	LinkedList<Peer> peers_pending = new LinkedList<Peer>();

	public testreceive (String[] args) throws IOException
	{
		InetAddress group = InetAddress.getByName (this.networkGroup);
		ProtocolFamily pf = group instanceof Inet4Address ? StandardProtocolFamily.INET : StandardProtocolFamily.INET6;
		NetworkInterface ni = NetworkInterface.getByName (this.interfaceName);
		if (null == ni) ni = NetworkInterface.getByInetAddress (InetAddress.getByName (this.interfaceName));
		DatagramChannel dc = DatagramChannel.open (pf)
			.setOption (StandardSocketOptions.SO_REUSEADDR, true)
			.bind (new InetSocketAddress (this.udpEncapsulationPort))
			.setOption (StandardSocketOptions.IP_MULTICAST_IF, ni);
		dc.configureBlocking (false);
		MembershipKey key = dc.join (group, ni);

		ByteBuffer buffer = ByteBuffer.allocateDirect (this.max_tpdu);
		SocketBuffer skb;
		PgmPacket packet;
/* Workaround Java lack of pass-by-reference for source peer. */
		Peer[] source = new Peer[1];
		long data_read = 0;

		Runtime.getRuntime().addShutdownHook (new Thread() {
			@Override
			public void run() {
				System.out.println ("fin.");
			}
		});

		Selector selector = Selector.open();
		SelectionKey sk = dc.register (selector, SelectionKey.OP_READ);
		while (true) {
			int keyCount = selector.select (1000);
			if (keyCount > 0) {
				selector.selectedKeys().clear();
				InetSocketAddress src = (InetSocketAddress)dc.receive (buffer);
				buffer.flip();
				byte[] packet_bytes = new byte [buffer.remaining()];
				buffer.get (packet_bytes, 0, packet_bytes.length);
				buffer.clear();
				skb = new SocketBuffer (packet_bytes, 0, packet_bytes.length);
				packet = PgmPacket.decode (skb);
				System.out.println ("packet: { " +
						  "\"address\": \"" + src.getAddress() + "\"" +
						", \"length\": " + packet_bytes.length + "" +
						" }");
				if (!packet.isValid())
					continue;
				source[0] = null;
				if (!this.onPgm (packet, src.getAddress(), group, source))
					continue;
/* check whether this source has waiting data */
				if (null != source[0] && source[0].hasPending()) {
					System.out.println ("New pending data.");
					this.peers_pending.addFirst (source[0]);
					source[0].setPendingLinkData();
				}
/* flush any congtiguous packets generated by the receipt of this packet */
				if (!this.peers_pending.isEmpty()) {
System.out.println ("#" + this.peers_pending.size());
					byte[] apdu_bytes = new byte[ReceiveWindow.MAX_APDU];
					int apdu_length = this.flushPeersPending (apdu_bytes, apdu_bytes.length);
System.out.println ("apdu_length=" + apdu_length);
					if (apdu_length > 0) {
						System.out.println ("msg: { " +
							  "\"data\": \"" + new String (apdu_bytes, 0, apdu_length) + "\"" +
							", \"length\": " + apdu_length + "" +
							" }");
					}
				}
/* repeat if non-blocking and not full */
				if (0 == data_read) {
//					...
				}
				if (0 == data_read) {
//					...
				}
//				if (!this.peers_pending.isEmpty()) {
//					...
//				}
			}
		}
	}

	private boolean onUpstream (
		PgmPacket packet,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		System.out.println ("onUpstream ( " +
					  "\"packet\": " + packet + "" +
					", \"sourceAddress\": \"" + sourceAddress.getHostAddress() + "\"" +
					", \"destinationAddress\": \"" + destinationAddress.getHostAddress() + "\"" +
					" )");
		return false;
	}

	private boolean onPeer (
		PgmPacket packet,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		System.out.println ("onPeer ( " +
					  "\"packet\": " + packet + "" +
					", \"sourceAddress\": \"" + sourceAddress.getHostAddress() + "\"" +
					", \"destinationAddress\": \"" + destinationAddress.getHostAddress() + "\"" +
					" )");
		return false;
	}

	private boolean onDownstream (
		PgmPacket packet,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source
		)
	{
		System.out.println ("onDownstream ( " +
					  "\"packet\": " + packet + "" +
					", \"sourceAddress\": \"" + sourceAddress.getHostAddress() + "\"" +
					", \"destinationAddress\": \"" + destinationAddress.getHostAddress() + "\"" +
					" )");

		if (!this.canReceiveData) {
			System.out.println ("Discarded packet for muted receiver.");
			return false;
		}

		if (packet.getDestinationPort() != this.dataDestinationPort) {
			System.out.println ("Discarded packet on data-destination port mismatch.");
			return false;
		}

		TransportSessionId tsi = packet.getTransportSessionId();
		source[0] = this.peers.get (tsi);
		if (null == source[0]) {
			source[0] = new Peer (tsi, this.max_tpdu, this.rxw_sqns, this.rxw_secs, this.rxw_max_rte);
			this.peers.put (tsi, source[0]);
		}

		source[0].setLastPacketTimestamp (packet.getTimestamp());
System.out.println ("Source: " + source[0]);

		switch (packet.getType()) {
		case PgmPacket.PGM_ODATA:
			if (!this.onOriginalData (source[0], (OriginalDataPacket)packet))
				return false;
			break;

		case PgmPacket.PGM_RDATA:
			if (!this.onRepairData (source[0], (RepairDataPacket)packet))
				return false;
			break;

		case PgmPacket.PGM_NCF:
			if (!this.onNakConfirm (source[0], packet))
				return false;
			break;

		case PgmPacket.PGM_SPM:
			if (!this.onSourcePathMessage (source[0], packet))
				return false;
			if (destinationAddress.isMulticastAddress())
				source[0].setGroupPath (destinationAddress);
			break;

		default:
			System.out.println ("Discarded unsupported PGM type packet.");
			return false;
		}

		return true;
	}

	private boolean onPgm (
		PgmPacket packet,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source
		)
	{
		System.out.println ("onPgm ( " +
					  "\"packet\": " + packet + "" +
					", \"sourceAddress\": \"" + sourceAddress.getHostAddress() + "\"" +
					", \"destinationAddress\": \"" + destinationAddress.getHostAddress() + "\"" +
					" )");

		if (packet.isDownstream())
			return this.onDownstream (packet, sourceAddress, destinationAddress, source);
		if (packet.getDestinationPort() == this.dataSourcePort)
		{
			if (packet.isUpstream() || packet.isPeer())
			{
				return this.onUpstream (packet, sourceAddress, destinationAddress);
			}
		}
		else if (packet.isPeer())
			return this.onPeer (packet, sourceAddress, destinationAddress);

		System.out.println ("Discarded unknown PGM packet.");
		return false;
	}

	private boolean onOriginalData (
		Peer source,
		OriginalDataPacket packet
		)
	{
		System.out.println ("onOriginalData ( " +
					  "\"source\": " + source + "" +
					", \"packet\": " + packet + "" +
					" )");

		int msgCount = 0;
		boolean flushNaks = false;

		final ReceiveWindow.Returns addStatus = source.add (packet);
System.out.println ("ReceiveWindow.add returned " + addStatus);

		switch (addStatus) {
		case RXW_MISSING:
			flushNaks = true;
		case RXW_INSERTED:
		case RXW_APPENDED:
			msgCount++;
			break;

		case RXW_DUPLICATE:
		case RXW_MALFORMED:
		case RXW_BOUNDS:
			return false;
		}

		return true;
	}

	private boolean onRepairData (
		Peer source,
		RepairDataPacket packet
		)
	{
		System.out.println ("onRepairData ( " +
					  "\"source\": " + source + "" +
					", \"packet\": " + packet + "" +
					" )");

		int msgCount = 0;
		boolean flushNaks = false;

		final ReceiveWindow.Returns addStatus = source.add (packet);

		switch (addStatus) {
		case RXW_MISSING:
			flushNaks = true;
		case RXW_INSERTED:
		case RXW_APPENDED:
			msgCount++;
			break;

		case RXW_DUPLICATE:
		case RXW_MALFORMED:
		case RXW_BOUNDS:
			return false;
		}

		return true;
	}

	private boolean onNakConfirm (
		Peer source,
		PgmPacket packet
		)
	{
		System.out.println ("onNakConfirm ( " +
					  "\"source\": " + source + "" +
					", \"packet\": " + packet + "" +
					" )");
		return true;
	}

	private boolean onSourcePathMessage (
		Peer source,
		PgmPacket packet
		)
	{
		System.out.println ("onSourcePathMessage ( " +
					  "\"source\": " + source + "" +
					", \"packet\": " + packet + "" +
					" )");
		return true;
	}

/* copy any contiguous buffers in the peer list to the provided buffer.
 */
	private int flushPeersPending (
			byte[] buffer,
			int buffer_length
			)
	{
System.out.println ("flushPeersPending");
		int bytes_read = 0;
		int data_read = 0;
		ListIterator it = this.peers_pending.listIterator();
		while (it.hasNext()) {
			Peer peer = (Peer)it.next();
			if (peer.hasLastCommit() && peer.getLastCommit() < this.lastCommit)
				peer.removeCommit();
			final int peer_bytes = peer.read (buffer, buffer_length);
System.out.println ("peer read=" + peer_bytes);
			if (peer.hasDataLoss())
				this.isReset = true;
			if (peer_bytes > 0) {
				bytes_read += peer_bytes;
				data_read++;
				peer.setLastCommit (this.lastCommit);
				if (bytes_read > buffer_length)
					return -1;
			} else
				peer.setLastCommit (0);
			if (this.isReset)
				return -1;
/* clear this reference and move to next */
			this.peers_pending.remove();
			peer.clearPendingLinkData();
		}
		return bytes_read;
	}

	public static void main(String[] args) throws IOException
	{
		new testreceive (args);
	}
}
