/* Example subscription to a PGM stream.
 */ 

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.net.*;
import java.util.*;

public class testreceive
{
/* Windows does not have convenient adapter names. */
//	String interfaceName = "10.0.9.30";
	String interfaceName = "eth0";
	String networkGroup = "239.192.0.1";
	int udpEncapsulationPort = 3056;
	int dataSourcePort = 0;
	int dataDestinationPort = 7500;
	int max_tpdu = 1500;
	int rxw_sqns = 128;
	int rxw_secs = 0;
	long rxw_max_rte = 0;
	long lastCommit = 0;
	boolean canReceiveData = true;
	boolean isReset = false;
	Hashtable<TransportSessionId, Peer> peers = new Hashtable<TransportSessionId, Peer>();
	LinkedList<Peer> peers_pending = new LinkedList<Peer>();

	public testreceive (String[] args) throws IOException
	{
		InetAddress group = InetAddress.getByName (this.networkGroup);
		ProtocolFamily pf = group instanceof Inet4Address ? StandardProtocolFamily.INET : StandardProtocolFamily.INET6;
		NetworkInterface ni = NetworkInterface.getByName (this.interfaceName);
		if (null == ni) ni = NetworkInterface.getByInetAddress (InetAddress.getByName (this.interfaceName));
		DatagramChannel dc = DatagramChannel.open (pf)
			.setOption (StandardSocketOptions.SO_REUSEADDR, true)
			.bind (new InetSocketAddress (this.udpEncapsulationPort))
			.setOption (StandardSocketOptions.IP_MULTICAST_IF, ni);
		dc.configureBlocking (false);
		MembershipKey key = dc.join (group, ni);

		ByteBuffer buffer = ByteBuffer.allocateDirect (this.max_tpdu);
		SocketBuffer skb;
/* Workaround Java lack of pass-by-reference for source peer. */
		Peer[] source = new Peer[1];
		long data_read = 0;

		Runtime.getRuntime().addShutdownHook (new Thread() {
			@Override
			public void run() {
				System.out.println ("fin.");
			}
		});

		Selector selector = Selector.open();
		SelectionKey sk = dc.register (selector, SelectionKey.OP_READ);
		while (true) {
			int keyCount = selector.select (1000);
			if (keyCount > 0) {
				selector.selectedKeys().clear();
				InetSocketAddress src = (InetSocketAddress)dc.receive (buffer);
				buffer.flip();
				skb = new SocketBuffer (buffer.remaining());
				skb.put (skb.getRawBytes().length);
				buffer.get (skb.getRawBytes(), 0, skb.getRawBytes().length);
				buffer.clear();
				skb.setTimestamp (System.currentTimeMillis());
/* Rx testing */
if (Math.random() < 0.25) {
	System.out.println ("Dropping packet.");
	continue;
}
				if (!Packet.parseUdpEncapsulated (skb))
					continue;
				source[0] = null;
				if (!this.onPgm (skb, src.getAddress(), group, source))
					continue;
/* check whether this source has waiting data */
				if (null != source[0] && source[0].hasPending()) {
					System.out.println ("New pending data.");
					this.peers_pending.addFirst (source[0]);
					source[0].setPendingLinkData();
				}
/* flush any congtiguous packets generated by the receipt of this packet */
				if (!this.peers_pending.isEmpty()) {
					byte[] apdu_bytes = new byte[ReceiveWindow.MAX_APDU];
					int apdu_length = this.flushPeersPending (apdu_bytes, apdu_bytes.length);
					if (apdu_length > 0) {
						System.out.println ("msg: { " +
							  "\"data\": \"" + new String (apdu_bytes, 0, apdu_length) + "\"" +
							", \"length\": " + apdu_length + "" +
							" }");
					}
				}
/* repeat if non-blocking and not full */
				if (0 == data_read) {
//					...
				}
				if (0 == data_read) {
//					...
				}
//				if (!this.peers_pending.isEmpty()) {
//					...
//				}
			}
		}
	}

	private boolean onUpstream (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		return false;
	}

	private boolean onPeer (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		return false;
	}

	private boolean onDownstream (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source
		)
	{
		if (!this.canReceiveData) {
			System.out.println ("Discarded packet for muted receiver.");
			return false;
		}

		if (skb.getHeader().getDestinationPort() != this.dataDestinationPort) {
			System.out.println ("Discarded packet on data-destination port mismatch.");
			return false;
		}

		TransportSessionId tsi = skb.getHeader().getTransportSessionId();
		source[0] = this.peers.get (tsi);
		if (null == source[0]) {
			source[0] = new Peer (tsi, this.max_tpdu, this.rxw_sqns, this.rxw_secs, this.rxw_max_rte);
			this.peers.put (tsi, source[0]);
		}

		source[0].setLastPacketTimestamp (skb.getTimestamp());

		skb.pull (Packet.SIZEOF_PGM_HEADER);

		switch (skb.getHeader().getType()) {
		case Packet.PGM_ODATA:
		case Packet.PGM_RDATA:
			if (!this.onData (source[0], skb))
				return false;
			break;

		case Packet.PGM_NCF:
			if (!this.onNakConfirm (source[0], skb))
				return false;
			break;

		case Packet.PGM_SPM:
			if (!this.onSourcePathMessage (source[0], skb))
				return false;
			if (destinationAddress.isMulticastAddress())
				source[0].setGroupPath (destinationAddress);
			break;

		default:
			System.out.println ("Discarded unsupported PGM type packet.");
			return false;
		}

		return true;
	}

	private boolean onPgm (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source			/* reference to a peer */
		)
	{
		if (skb.getHeader().isDownstream())
			return this.onDownstream (skb, sourceAddress, destinationAddress, source);
		if (skb.getHeader().getDestinationPort() == this.dataSourcePort)
		{
			if (skb.getHeader().isUpstream() || skb.getHeader().isPeer())
			{
				return this.onUpstream (skb, sourceAddress, destinationAddress);
			}
		}
		else if (skb.getHeader().isPeer())
			return this.onPeer (skb, sourceAddress, destinationAddress);

		System.out.println ("Discarded unknown PGM packet.");
		return false;
	}

	private boolean onData (
		Peer source,
		SocketBuffer skb
		)
	{
		int msgCount = 0;
		boolean flushNaks = false;

		skb.setOriginalDataOffset (skb.getDataOffset());

		final int opt_total_length = skb.getAsOriginalData().getOptionTotalLength();

/* advance data pointer to payload */
		skb.pull (OriginalData.SIZEOF_DATA_HEADER + opt_total_length);

		if (opt_total_length > 0)
			Packet.parseOptionExtensions (skb, skb.getDataOffset());

		final ReceiveWindow.Returns addStatus = source.add (skb);
System.out.println ("ReceiveWindow.add returned " + addStatus);

		switch (addStatus) {
		case RXW_MISSING:
			flushNaks = true;
		case RXW_INSERTED:
		case RXW_APPENDED:
			msgCount++;
			break;

		case RXW_DUPLICATE:
		case RXW_MALFORMED:
		case RXW_BOUNDS:
			return false;
		}

		return true;
	}

	private boolean onNakConfirm (
		Peer source,
		SocketBuffer skb
		)
	{
		return true;
	}

	private boolean onSourcePathMessage (
		Peer source,
		SocketBuffer skb
		)
	{
		return true;
	}

/* copy any contiguous buffers in the peer list to the provided buffer.
 */
	private int flushPeersPending (
			byte[] buffer,
			int buffer_length
			)
	{
System.out.println ("flushPeersPending");
		int bytes_read = 0;
		int data_read = 0;
		ListIterator it = this.peers_pending.listIterator();
		while (it.hasNext()) {
			Peer peer = (Peer)it.next();
			if (peer.hasLastCommit() && peer.getLastCommit() < this.lastCommit)
				peer.removeCommit();
			final int peer_bytes = peer.read (buffer, buffer_length);
			if (peer.hasDataLoss())
				this.isReset = true;
			if (peer_bytes > 0) {
				bytes_read += peer_bytes;
				data_read++;
				peer.setLastCommit (this.lastCommit);
				if (bytes_read > buffer_length)
					return -1;
			} else
				peer.setLastCommit (0);
			if (this.isReset)
				return -1;
/* clear this reference and move to next */
			this.peers_pending.remove();
			peer.clearPendingLinkData();
		}
		return bytes_read;
	}

	public static void main (String[] args) throws IOException
	{
		new testreceive (args);
	}
}

/* eof */
