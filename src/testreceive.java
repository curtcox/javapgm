/* Example subscription to a PGM stream.
 */ 

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.net.*;
import java.util.*;

public class testreceive
{
/* Windows does not have convenient adapter names. */
//	String interfaceName = "10.0.9.30";
	String interfaceName = "eth0";
	String networkGroup = "239.192.0.1";
	int udpEncapsulationPort = 3056;
	int dataSourcePort = 0;
	int dataDestinationPort = 7500;
	int max_tpdu = 1500;
	int rxw_sqns = 3; //128;
	int rxw_secs = 0;
	long rxw_max_rte = 0;
	long lastCommit = 0;
	boolean canReceiveData = true;
	boolean isReset = false;
	DatagramChannel dc = null;
	ByteBuffer buffer = null;
	SocketBuffer rx_buffer = null;
	InetAddress group = null;
/* Workaround Java lack of pass-by-reference for source peer. */
	Peer[] source = new Peer[1];
	Hashtable<TransportSessionId, Peer> peers = new Hashtable<TransportSessionId, Peer>();
	LinkedList<Peer> peers_pending = new LinkedList<Peer>();

	public enum IoStatus {
		IO_STATUS_ERROR,
		IO_STATUS_NORMAL,
		IO_STATUS_RESET,
		IO_STATUS_FIN,
		IO_STATUS_EOF,
		IO_STATUS_WOULD_BLOCK,
		IO_STATUS_RATE_LIMITED,
		IO_STATUS_TIMER_PENDING,
		IO_STATUS_CONGESTION
	}

	public testreceive (String[] args) throws IOException
	{
		this.group = InetAddress.getByName (this.networkGroup);
		ProtocolFamily pf = this.group instanceof Inet4Address ? StandardProtocolFamily.INET : StandardProtocolFamily.INET6;
		NetworkInterface ni = NetworkInterface.getByName (this.interfaceName);
		if (null == ni) ni = NetworkInterface.getByInetAddress (InetAddress.getByName (this.interfaceName));
		this.dc = DatagramChannel.open (pf)
			.setOption (StandardSocketOptions.SO_REUSEADDR, true)
			.bind (new InetSocketAddress (this.udpEncapsulationPort))
			.setOption (StandardSocketOptions.IP_MULTICAST_IF, ni);
		this.dc.configureBlocking (false);
		MembershipKey key = this.dc.join (this.group, ni);

		this.buffer = ByteBuffer.allocateDirect (this.max_tpdu);

		Runtime.getRuntime().addShutdownHook (new Thread() {
			@Override
			public void run() {
				System.out.println ("fin.");
			}
		});

		Selector selector = Selector.open();
		SelectionKey sk = this.dc.register (selector, SelectionKey.OP_READ);
		while (true) {
			final int keyCount = selector.select (1000);
			if (keyCount > 0) {
				selector.selectedKeys().clear();

				final List<SocketBuffer> skbs = new ArrayList<SocketBuffer>();
				final IoStatus status = receive (skbs);
				switch (status) {
				case IO_STATUS_NORMAL:
					on_data (skbs);
					break;
				case IO_STATUS_TIMER_PENDING:
					System.out.println ("timer pending ...");
					break;
				case IO_STATUS_RATE_LIMITED:
					System.out.println ("rate limited ...");
					break;
				case IO_STATUS_WOULD_BLOCK:
					System.out.println ("would block.");
					break;
				default:
					System.out.println ("error");
					break;
				}
			}
		}
	}

	private void on_data (List<SocketBuffer> skbs) {
		System.out.println ("Received " + skbs.size() + " SKBs");
		int i = 1;
		for (SocketBuffer skb : skbs) {
			System.out.println ("#" + (i++) + " from " + skb.getTransportSessionId() + ": " +
				"\"" + new String (skb.getRawBytes(), skb.getDataOffset(), skb.getLength()) + "\"");
		}
	}

	private IoStatus receive (List<SocketBuffer> skbs) throws IOException {
		IoStatus status = IoStatus.IO_STATUS_WOULD_BLOCK;

		if (this.isReset) {
			return IoStatus.IO_STATUS_RESET;
		}

/* timers */

		if (0 == ++(this.lastCommit))
			++(this.lastCommit);

		do {
/* second, flush any remaining contiguous messages from previous call(s) */
			if (!this.peers_pending.isEmpty()) {
				if (0 != flushPeersPending (skbs))
					break;
			}
		
			do {
				InetSocketAddress src = (InetSocketAddress)this.dc.receive (this.buffer);
				this.buffer.flip();
				this.rx_buffer = new SocketBuffer (this.buffer.remaining());
				this.rx_buffer.put (this.rx_buffer.getRawBytes().length);
				this.buffer.get (this.rx_buffer.getRawBytes(), 0, this.rx_buffer.getRawBytes().length);
				this.buffer.clear();
				this.rx_buffer.setTimestamp (System.currentTimeMillis());
/* Rx testing */
//if (Math.random() < 0.25) {
//	System.out.println ("Dropping packet.");
//	continue;
//}
				if (!Packet.parseUdpEncapsulated (this.rx_buffer))
					break;
				this.source[0] = null;
				if (!onPgm (this.rx_buffer, src.getAddress(), this.group, this.source))
					break;
/* check whether this source has waiting data */
				if (null != this.source[0] && this.source[0].hasPending()) {
					System.out.println ("New pending data.");
					this.peers_pending.addFirst (this.source[0]);
					this.source[0].setPendingLinkData();
				}
/* flush any congtiguous packets generated by the receipt of this packet */
				if (!this.peers_pending.isEmpty()) {
					if (0 != flushPeersPending (skbs))
						break;
				}
			} while (false);
		} while (false);

		if (skbs.isEmpty()) {
			if (this.isReset) {
				return IoStatus.IO_STATUS_RESET;
			}
			if (IoStatus.IO_STATUS_WOULD_BLOCK == status &&
				!this.peers.isEmpty())
			{
				return IoStatus.IO_STATUS_TIMER_PENDING;
			}
			return status;
		}

		return IoStatus.IO_STATUS_NORMAL;
	}

	private boolean onUpstream (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		return false;
	}

	private boolean onPeer (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress
		)
	{
		return false;
	}

	private boolean onDownstream (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source
		)
	{
		if (!this.canReceiveData) {
			System.out.println ("Discarded packet for muted receiver.");
			return false;
		}

		if (skb.getHeader().getDestinationPort() != this.dataDestinationPort) {
			System.out.println ("Discarded packet on data-destination port mismatch.");
			return false;
		}

		TransportSessionId tsi = skb.getHeader().getTransportSessionId();
		source[0] = this.peers.get (tsi);
		if (null == source[0]) {
			source[0] = new Peer (tsi, this.max_tpdu, this.rxw_sqns, this.rxw_secs, this.rxw_max_rte);
			this.peers.put (tsi, source[0]);
		}

		source[0].setLastPacketTimestamp (skb.getTimestamp());

		skb.pull (Packet.SIZEOF_PGM_HEADER);

		switch (skb.getHeader().getType()) {
		case Packet.PGM_ODATA:
		case Packet.PGM_RDATA:
			if (!this.onData (source[0], skb))
				return false;
			break;

		case Packet.PGM_NCF:
			if (!this.onNakConfirm (source[0], skb))
				return false;
			break;

		case Packet.PGM_SPM:
			if (!this.onSourcePathMessage (source[0], skb))
				return false;
			if (destinationAddress.isMulticastAddress())
				source[0].setGroupPath (destinationAddress);
			break;

		default:
			System.out.println ("Discarded unsupported PGM type packet.");
			return false;
		}

		return true;
	}

	private boolean onPgm (
		SocketBuffer skb,
		InetAddress sourceAddress,
		InetAddress destinationAddress,
		Peer[] source			/* reference to a peer */
		)
	{
		if (skb.getHeader().isDownstream())
			return this.onDownstream (skb, sourceAddress, destinationAddress, source);
		if (skb.getHeader().getDestinationPort() == this.dataSourcePort)
		{
			if (skb.getHeader().isUpstream() || skb.getHeader().isPeer())
			{
				return this.onUpstream (skb, sourceAddress, destinationAddress);
			}
		}
		else if (skb.getHeader().isPeer())
			return this.onPeer (skb, sourceAddress, destinationAddress);

		System.out.println ("Discarded unknown PGM packet.");
		return false;
	}

	private boolean onData (
		Peer source,
		SocketBuffer skb
		)
	{
		int msgCount = 0;
		boolean flushNaks = false;

		skb.setOriginalDataOffset (skb.getDataOffset());

		final int opt_total_length = skb.getAsOriginalData().getOptionTotalLength();

/* advance data pointer to payload */
		skb.pull (OriginalData.SIZEOF_DATA_HEADER + opt_total_length);

		if (opt_total_length > 0)
			Packet.parseOptionExtensions (skb, skb.getDataOffset());

		final ReceiveWindow.Returns addStatus = source.add (skb);
System.out.println ("ReceiveWindow.add returned " + addStatus);

		switch (addStatus) {
		case RXW_MISSING:
			flushNaks = true;
		case RXW_INSERTED:
		case RXW_APPENDED:
			msgCount++;
			break;

		case RXW_DUPLICATE:
		case RXW_MALFORMED:
		case RXW_BOUNDS:
			return false;
		}

		return true;
	}

	private boolean onNakConfirm (
		Peer source,
		SocketBuffer skb
		)
	{
		return true;
	}

	private boolean onSourcePathMessage (
		Peer source,
		SocketBuffer skb
		)
	{
		return true;
	}

/* copy any contiguous buffers in the peer list to the provided buffer.
 */
	private int flushPeersPending (
			List<SocketBuffer> skbs
			)
	{
System.out.println ("flushPeersPending");
		int bytes_read = 0;
		int data_read = 0;
		ListIterator it = this.peers_pending.listIterator();
		while (it.hasNext()) {
			Peer peer = (Peer)it.next();
			if (peer.hasLastCommit() && peer.getLastCommit() < this.lastCommit)
				peer.removeCommit();
			final int peer_bytes = peer.read (skbs);
			if (peer.hasDataLoss())
				this.isReset = true;
			if (peer_bytes > 0) {
				bytes_read += peer_bytes;
				data_read++;
				peer.setLastCommit (this.lastCommit);
			} else
				peer.setLastCommit (0);
			if (this.isReset)
				return -1;
/* clear this reference and move to next */
			this.peers_pending.remove();
			peer.clearPendingLinkData();
		}
		return bytes_read;
	}

	public static void main (String[] args) throws IOException
	{
		new testreceive (args);
	}
}

/* eof */
